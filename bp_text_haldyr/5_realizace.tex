\chapter{Realizace} \label{realizace}
% Popis implementace/realizace se zaměřením na nestandardní části řešení.
% A tady budu řešit jednotlivé Cisco příkazy - jak jsem na to přicházel, postupné problémy, moje implementace a odchylky.

% \begin{itemize}
%  \item směrování prijmiEthernetove()
%  \item wrapper pro routovací tabulku
%  \item překlad adres
%  \item příkaz Uloz
%  \item SAXHandler
%  \item CiscoParserPrikazu
%  \item Cisco příkazy
%     \begin{itemize}
%      \item Parsery
%      \item ???
%     \end{itemize}
% \end{itemize}

Předkem všech tříd systému na aplikační vrstvě je \verb|Abstraktni|, která zastřešuje převážně statické funkce např. \verb|zaokrouhli| (na tři desetinná místa), \verb|cekej| (metoda pro uspání vlákna, užitečná při výpisech Cisco IOS) a další. Od \verb|Abstraktni| dědí abstraktní \verb|ParserPrikazu|, který seskupuje všechny parsery příkazů (v současné době pro Linux a Cisco IOS). Společný předek Linux a Cisco příkazů je \verb|AbtraktniPrikaz|, z kterého dědí linuxové příkazy kolegy a hlavně \verb|CiscoPrikaz|, který ještě přidává speciálné metody jen pro Cisco příkazy. Viz obrázek \ref{uml:abstraktni}.

\begin{figure}[h]
\begin{center}
\includegraphics[width=9cm]{figures/uml_abtraktni.png}
\caption{Třídní model předků}
\label{uml:abstraktni}
\end{center}
\end{figure}

Téméř všechny části systému obsahují tzv. debugovací mód, který vypisuje extra informace, co se právě děje nebo přidává další vlastnost vhodnou pro ladění.

\section{Parser Cisco}
Po návrhu a implementaci jádra systému se moje úsilí přesunulo k parseru příkazů pro Cisco. 
% Metoda \verb|zpracujRadek()| je klíčová, protože to je právě ona, kdo rozhoduje, komu bude předáno řízení programu. 

\subsection{Cisco IOS}
Cisco IOS je operační systém, který se nachází na drtivé většině směrovačů firmy Cisco Systems. IOS obsahuje pouze ovládání přes příkazový řádek - CLI\footnote{Command Line Interface}. Pro mě je to spíše výhodou, protože je to mnohem jednodušší na implementaci ve srovnání s \uv{klikacím} GUI\footnote{Graphical User Interface}. IOS má implementováno tzv. zkracování příkazů, které zefektivňuje práci s celým systémem. Celé to funguje tak, že když uživatelův začátek příkazu lze doplnit na jedinečný příkaz (samotné doplnění přes klávesu \verb|TAB|), tak to takový příkaz hned zavolá. Například příkaz \verb|sh run| lze jednoznačně doplnit na \verb|show running-config|, ale kratší \verb|sh ru| už ne:
\begin{verbatim}
Router#sh ru?
rudpv1  running-config
\end{verbatim} 

IOS tvoří několik stavů, např.:
\begin{itemize}
 \item uživatelský mód
 \item privilegovaný mód
 \item konfigurační mód - zde se nastavují volby, které ovlivní celý systém
 \item konfigurace rozhraní - konfigurace jednoho určitého rozhraní
\end{itemize}

\begin{figure}[h]
\begin{center}
\includegraphics[width=13cm]{figures/ios.png}
\caption{Přehled základních módů Cisco IOS \cite{wiki:ios}}
\label{fig:ios}
\end{center}
\end{figure}

Na obrázku \ref{fig:ios} jsou zobrazeny důležité stavy IOS a přechody mezi nimi. 

\subsubsection{Uživatelský mód}
Uživatelský mód (USER MODE) je výchozí (startovací) mód. Tento mód je značně limitovaný a dovoluje použití čistě read-only příkazů (tj. takových, které nezmění konfiguraci). Přesto má tento mód svoje opodstatnění, dovoluje např. výpis směrovací tabulky \verb|show ip route| či příkazy \verb|ping| nebo \verb|traceroute|. Do privilegovaného režimu se lze přepnout příkazem \verb|enable|.

\subsubsection{Privilegovaný mód}
Privilegovaný mód (PRIVILEGED MODE) nebo také \uv{administrátorský} mód je podobný linuxovému \verb|root| účtu. Tento mód je výchozím bodem pro vstup do ostatních módů. Pro návrat zpět do uživatelského režimu existuje příkaz \verb|disable|. Příkaz \verb|configure| způsobí přepnutí do dalšího konfiguračního módu. Tento stav umožnuje vypsat veškeré informace o aktuální konfiguraci systému, např.:
\begin{itemize}
 \item \verb|show running-config| - shrnutí aktuální konfigurace
 \item \verb|show ip route| - výpis směrovací tabulky
 \item \verb|show ip nat translations| - výpis dynamických záznamů v NAT tabulce
\end{itemize}
Není důvod, proč by v tomto stavu nefungovaly příkazy \verb|ping| a \verb|traceroute|.

\subsubsection{Konfigurační mód}
Konfigurační mód (CONFIG MODE) je jeden z nejdůležitějších, protože umožňuje konfiguraci směrovacích záznamů (\verb|ip route|), přístupových seznamů pro potřeby překladu adres (\verb|access-list|), pooly IP adres (\verb|ip nat pool|) a výběr rozhraní pro přechod do stavu konfigurace rozhraní (\verb|interface|).

\subsubsection{Konfigurace rozhraní} \label{configif}
V tomto módu lze nastavovat IP adresy na aktuálně vybrané rozhraní, nastavovat příznaky pro veřejné a soukromé rozhraní pro NAT (\verb|nat inside|, \verb|nat outside|) nebo také zapínat či vypínat rozhraní. Pro přechod ze všech konfiguračních módů do privilegovaného stačí napsat příkaz \verb|end| nebo jen stisknout klávesovou zkratku \verb|Ctrl+Z|.


\subsection{Implementace Cisco IOS}
Cisco IOS obsahuje desítky příkazů z nichž každý může mít až stovky variací. Proto jsem implementoval pouze úzkou část příkazů, která je potřebná pro splnění zadání této práce. Nejdůležitější funkcí parseru je rozpoznávání zkrácených příkazů. Na skutečném Ciscu se opravdu procházejí všechny možnosti, které mohou v daném stavu nastat, a podle nich probíhá vyhodnocování. V mé implementaci ale mám pouze část příkazů, takže jsem to musel vyřešit jiným způsobem. Pro každé slovo (část příkazu) si \verb|CiscoParserPrikazu| drží počet písmen, který je potřeba k jednoznačnému určení příkazu. Tato čísla jsem \uv{naměřil} na školních ciscách v březnu 2010. Zajímavé je, že už o 2 měsíce později jsem objevil drobné změny. Čísla se mohou měnit s různými verzemi Cisco IOS. To bych ale neviděl jako zásádní problém. Většina studentů (alespoň dle mé zkušenosti) stejně píše celé příkazy a zkrácené verze nepoužívá.

Vyhodnocování příkazů zajišťuje metoda \verb|kontrola(command, cmd)|. Parametr \verb|command| je celý příkaz, na který by se to mohlo eventuelně doplnit, a \verb|cmd| je příkaz poslaný od uživatele. Nejdříve se zjistí počet znaků, který je potřeba pro jednoznačné doplnění na příkaz \verb|command|. Po té se zkontroluje požadovaný počet znaků a také jestli zkrácený příkaz odpovídá doplněnému. A jak to vypadá v kódu:

\begin{verbatim}
if (cmd.length() >= i && command.startsWith(cmd)) {
    // lze doplnit na jeden jedinecny prikaz
    return true;
}
if (command.startsWith(cmd)) {
    // vypsat amiguous command
    nepokracovat = true;
}
\end{verbatim}

Jednotlivé příkazy Cisco IOS jsou implementovány v samostatných třídách. Třída \\\verb|CiscoParserPrikazu| tedy zajišťuje přechody mezi stavy (módy) a \uv{nahazování} rozhraní. Přepnutí stavu rozhraní je natolik triviální, že se by se nevyplatilo mít pro to zvláštní třídu. 

\paragraph{}
Ladící mód zjednodušuje testování parseru a přidává tyto funkce:
\begin{itemize}
 \item klávesa \verb|Enter| funguje jako přechod z uživatelského do privilegovaného módu
 \item použití příkazů z jiných módů v privilegovaném módu - navíc např. \verb| ip route|, \\\verb|ip nat pool inside|, \verb|access-list|, ..
 \item extra výpis dynamických záznamů v natovací tabulce
 \item výpis \verb|show running-config| je pro přehlednost zkrácen
 \item možnost testování routovací tabulky přes linuxový příkaz \verb|route|
 \item používání linuxového příkazu \verb|ifconfig|
\end{itemize}
Použití těchto věcí je vhodné spíše pro ladění programu do budoucna než pro běh v \uv{ostrém} provozu. Tento mód je ve výchozím stavu vypnut.

\subsection{Odchylky v implementaci}
Má implementace Cisco IOS má navíc pár příkazů, které jsou potřeba pro ovládání systému. Jak už jsem se zmiňoval v kapitole \ref{kap:podobnost} je zde navíc \verb|help| a \verb|help_en| pro výpis nápovědy. Příkaz \verb|kill| přijde vhod, když uživatel chce ihned vypnout aplikaci a nechce projít přes několik stavů příkazem \verb|exit|. Další servisní příkaz je \verb|save| nebo také \verb|uloz|, který zapíše aktuální konfiguraci všech počítačů do konfiguračního souboru, se kterým byl spuštěn nebo který byl předán jako parametr. Dále lze využít velmi jednoduchý příkaz \verb|?| (otazník), který vypíše seznam dostupných příkazů v aktuálním stavu.

Na skutečném Ciscu funguje kombinace kláves \verb|Ctrl+Z| pro přechod do privilegovaného módu. Ale kvůli použití programu\verb|rlwrap| je systém limitován. Omezení spočívá v tom, že \verb|rlwrap| přepošle signál operačnímu systému a ten pozastaví tento proces. Proces lze obnovit příkazem fg (na OS Linux), bohužel klientský program \verb|telnet| neumí po pozastavení obnovit svoji funkčnost a přestává posílat vstup na standartní výstup. Je tedy už nepoužitelný a pro tyto přídady existuje příkaz \verb|kill|, který ukončí tento rozbitý proces a klient se může přípojit znova. Lépe je na tom zkratka \verb|Ctrl+C|, která pouze ukončuje (signál SIG\_INT) daný proces a tedy funguje bez problému. 

Program \verb|rlwrap| je ale šířen jako balíček pod programem \verb|cygwin| v zastaralé verzi\footnote{stav z 18.5.2010}, která neumožňuje přeposílání signálů, takže při stisku \verb|Ctrl+C| i \verb|Ctrl+Z| přestane \verb|telnet| klient vypisovat na standartní výstup a nezbývá než použít \verb|kill|.








% \lstinline{System.out.println("Tady je text")}



